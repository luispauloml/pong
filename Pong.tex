
\documentclass[12pt,a4paper,oneside]{article}
\usepackage[a4paper]{geometry}
\usepackage[brazil]{babel}
\usepackage{indentfirst}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=3cm,rmargin=3cm}

%---------------------------------------------------------------

\usepackage{hyperref}
\hypersetup{colorlinks=true}

%---------------------------------------------------------------

%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%

\begin{document}

%---------------------------------------------------------------
%---------------------------------------------------------------

\title{\texttt{Pong}: simples implementa\c c\~ao em Haskell}
\author{Luis Paulo Lima}
\date{\today}
\maketitle
\tableofcontents{}

%---------------------------------------------------------------
%---------------------------------------------------------------

\section{Introdu\c cao}

O prop\'osito deste trabalho \'e entender como funciona programa\c cao liter\'aria em Haskell e praticar algumas funcionalidades da pr\'opria linguagem.
Dentre elas, usei principalmente 
\href{http://hackage.haskell.org/package/lens}{\text{\ttfamily lens}} e a m\^onada \text{\ttfamily Maybe}. 
Toda a implementa\c c\~ ao \' e baseada no pacote
\href{http://hackage.haskell.org/package/gloss}{\text{\ttfamily gloss}}.
Todas as a\c c\~ oes I/O s\~ ao realizadas por ele, sendo que \text{\ttfamily IO} s\'o foi usada durante o desenvolvimento para \emph{debugging}, quando necess\'ario.


\begin{tabbing}\texfamily
{\rmfamily\enskip\{-\# LANGUAGE TemplateHaskell  \#-\}\enskip}\\
\texfamily \\
\texfamily {\bfseries module}~{\itshape Main}~{\bfseries where}\\
\texfamily \\
\texfamily {\bfseries import}~{\itshape {\itshape Control}.Lens}\\
\texfamily {\bfseries import}~{\itshape {\itshape Data}.Maybe}\\
\texfamily {\bfseries import}~{\itshape {\itshape Graphics}.Gloss}\\
\texfamily {\bfseries import}~{\itshape {\itshape Graphics}.{\itshape Gloss}.Interface}\char'00{\itshape {\itshape IO}.Game}\\
\texfamily {\bfseries import}~{\itshape {\itshape System}.Random}
\end{tabbing}


Seguindo a ideia da programa\c c\~ao liter\'aria, eu come\c co o desenvolvimento
criando os tipos que ser\~ao usados e as lentes para operar em alguns deles.
Depois, algumas constante globais que ser\~ao usadas ao decorrer da implementa\c c\~ao,
e o estado inicial do jogo e o procedimento de incio da partida.

%---------------------------------------------------------------
%---------------------------------------------------------------

\section{Tipos}

Os tipos b\'asicos s\~ao usados para representar a dire\c c\~ao de movimento dos jogadores e posi\c c\~oes relativas \`a tela.

\begin{tabbing}\texfamily
{\bfseries data}~{\itshape Direcao}~=~{\itshape Cima}~|~{\itshape Baixo}~|~{\itshape Parado}~{\bfseries deriving}~({\itshape Eq},~{\itshape Show})\\
\texfamily {\bfseries data}~{\itshape Lado}~=~{\itshape Topo}~|~{\itshape Base}~|~{\itshape Dir}~|~{\itshape Esq}~{\bfseries deriving}~({\itshape Eq},~{\itshape Show})
\end{tabbing}
Quanto ao universo do jogo, s\~ao usados registros (\emph{records}) para armazenar o estado da bola e dos jogadores.

\begin{tabbing}\texfamily
{\bfseries data}~{\itshape Jogador}~=~{\itshape Jogador}\\
\texfamily ~~~~~~~~~~~~~\char123 ~\char95 posY~~~::~{\itshape Float}~~~~~~~~{\rmfamily-{}-  Posicao vertical da barra}\\
\texfamily ~~~~~~~~~~~~~,~\char95 dirMov~::~{\itshape Direcao}~~~~~~{\rmfamily-{}-  Direcao atual do movimento}\\
\texfamily ~~~~~~~~~~~~~,~\char95 pts~~~~::~{\itshape Int}~~~~~~~~~~{\rmfamily-{}-  Pontuacao do jogador}\\
\texfamily ~~~~~~~~~~~~~\char125 ~{\bfseries deriving}~({\itshape Eq},~{\itshape Show})\\
\texfamily ~~~~~~~~~~~~~\\
\texfamily {\bfseries data}~{\itshape Bola}~=~{\itshape Bola}\\
\texfamily ~~~~~~~~~~\char123 ~\char95 veloc~~~::~{\itshape Float}~~~~~~~~~~{\rmfamily-{}-  Magnitude da velocdiade}\\
\texfamily ~~~~~~~~~~,~\char95 angulo~~::~{\itshape Float}~~~~~~~~~~{\rmfamily-{}-  Angulo do movimento da bola}\\
\texfamily ~~~~~~~~~~,~\char95 posXY~~~::~({\itshape Float},{\itshape Float})~~{\rmfamily-{}-  Posicao XY da bola}\\
\texfamily ~~~~~~~~~~\char125 ~{\bfseries deriving}~({\itshape Eq},~{\itshape Show})
\end{tabbing}

Para o jogo como um todo, al\'em de armazenar dois jogadores mais a bola, alguns dados adicionais s\~ao necess\'arios:
\begin{enumerate}
    \item Onde ocorreu o \'ultimo toque: para evitar o \emph{bug} de uma bola muito lenta ficar rebatendo idefinidamente caso estiver muito pr\'oxima de um objeto.
    
    \item De que lado ocorreu o \'ultimo ponto: usado para determinar de que lado a bola come\c ca no ponto seguinte.
    
    \item Contador de tempo: para atrasar o recome\c co quando houver ponto.
    
\end{enumerate}

\begin{tabbing}\texfamily
{\bfseries data}~{\itshape Jogo}~=~{\itshape Jogo}\\
\texfamily ~~~~~~~~~~\char123 ~\char95 player1~~~~~::~{\itshape Jogador}~~{\rmfamily-{}-  Jogador 1}\\
\texfamily ~~~~~~~~~~,~\char95 player2~~~~~::~{\itshape Jogador}~~{\rmfamily-{}-  Jogador 2}\\
\texfamily ~~~~~~~~~~,~\char95 pong~~~~~~~~::~{\itshape Bola}~~~~~{\rmfamily-{}-  Bola do jogo}\\
\texfamily ~~~~~~~~~~,~\char95 ultimoToque~::~{\itshape Lado}~~~~~{\rmfamily-{}-  Armazena lado do ultimo toque}\\
\texfamily ~~~~~~~~~~,~\char95 ultimoPonto~::~{\itshape Lado}~~~~~{\rmfamily-{}-  Lado onde foi feito o ultimo ponto}\\
\texfamily ~~~~~~~~~~,~\char95 atrasoPonto~::~{\itshape Float}~~~~{\rmfamily-{}-  Contador de tempo para atraso}\\
\texfamily ~~~~~~~~~~\char125 ~{\bfseries deriving}~({\itshape Eq},~{\itshape Show})~~~~~~~~
\end{tabbing}

%---------------------------------------------------------------

Perecebe-se que cada campo do registro come\c ca por um tra\c co inferior (\text{\ttfamily \char95{}}).
Eles uma exig\^encia para facilitar a cria\c c\~ao das lentes: 

\begin{tabbing}\texfamily
makeLenses~''{\itshape Jogador}\\
\texfamily makeLenses~''{\itshape Bola}\\
\texfamily makeLenses~''{\itshape Jogo}
\end{tabbing}

A fun\c c\~ao \text{\ttfamily makeLenses} usa metaprograma\c c\~ao para criar as lentes dos registros, a qual j\'a foi habilitada pela extens\~ao \text{\ttfamily TemplateHaskell} no cabe\c calho.
Cada campo definido num registro torna-se por se s\'o uma fun\c c\~ao de acesso aos dados armazenados:

\begin{tabbing}\texfamily
~\char95 campo~::~a~\char'31~b~
\end{tabbing}

Quando a lente \'e criada, uma nova fun\c c\~ao \'e criada para ser usada com \text{\ttfamily over}, \text{\ttfamily set} ou \text{\ttfamily view}, do pacote \text{\ttfamily lens}:

\begin{tabbing}\texfamily
~campo~::~{\itshape Functor}~f~=>~(b~\char'31~f~b)~\char'31~a~\char'31~f~a~
\end{tabbing}

Por exemplo, \text{\ttfamily set} \'e usada para sobrescrever algum dado num registro.
Se usada para alterar a bola (\text{\ttfamily \char95{}pong}) no estado geral do jogo (\text{\ttfamily Jogo}), tem-se:

\begin{tabbing}\texfamily
~~set~pont~::~{\itshape Bola}~\char'31~{\itshape Jogo}~\char'31~{\itshape Jogo}
\end{tabbing}
%\eval{:t set pong}.

%---------------------------------------------------------------
%---------------------------------------------------------------

\section{Constantes globais}

Por se tratar de um jogo gr\'afico, definir algumas constantes globais torna o programa mais leg\'ivel:
em vez de passar v\'arios argumentos para v\'arias fun\c c\~oes que dependem da geometria dos objetos na tela, \'e mais f\'acil apenas invocar o valor global.
H\'a tr\^es constantes b\'asicas, e outras cinco definidas em fun\c c\~ao dessas primeiras.

%---------------------------------------------------------------

\subsection{Constates b\'asicas}

As tr\^es principais s\~ao:
\begin{enumerate}

\item Taxa de quadros por segundo para atualiza\c c\~ao da tela (Hz).
\begin{tabbing}\texfamily
fps~~~~~~~~~~::~{\itshape Int}\\
\texfamily fps~~~~~~~~~~=~60~~~~~~~~~
\end{tabbing}

\item Tempo de atraso entre os pontos (s).
\begin{tabbing}\texfamily
delayInit~~~~::~{\itshape Float}\\
\texfamily delayInit~~~~=~1
\end{tabbing}

\item Dimens\~oes $(x,y)$ da janela (px).
\begin{tabbing}\texfamily
tamJanela~~~~::~({\itshape Int},~{\itshape Int})\\
\texfamily tamJanela~~~~=~(800,600)~~
\end{tabbing}
\end{enumerate}

%---------------------------------------------------------------

\subsection{Consates derivadas}

As demais s\~ao definidas todas elas em fun\c c\~ao do tamanho da janela,
e entre si mesmas:
\begin{enumerate}

\item Raio da bola (px).

\begin{tabbing}\texfamily
raioBola~~~~~::~{\itshape Float}~\\
\texfamily raioBola~~~~~=~0.02~*~(fromIntegral~\$~snd~tamJanela)
\end{tabbing}

\item Largura do jogador (px).

\begin{tabbing}\texfamily
ladoJogador~~::~{\itshape Float}~\\
\texfamily ladoJogador~~=~raioBola
\end{tabbing}

\item Comprimento do jogador (px).

\begin{tabbing}\texfamily
compJogador~~::~{\itshape Float}~\\
\texfamily compJogador~~=~10~*~ladoJogador
\end{tabbing}

\item Passo do movimento do jogador a cada quadro (px).

\begin{tabbing}\texfamily
passoJogador~::~{\itshape Float}~\\
\texfamily passoJogador~=~0.2~*~compJogador
\end{tabbing}

\item Limites da janela a partir do centro (px):
superior, inferior, esquerda e direita.

\begin{tabbing}\texfamily
limJanela~~~~::~({\itshape Float},~{\itshape Float},~{\itshape Float},~{\itshape Float})~\\
\texfamily limJanela~~~~=~(,,,)\\
\texfamily ~~~~~~~~~~~~~~~~{\rmfamily-{}-  Fundo direito}\\
\texfamily ~~~~~~~~~~~~~~~~((fromIntegral~~~(fst~tamJanela)~)~/~2)~~~\\
\texfamily ~~~~~~~~~~~~~~~~{\rmfamily-{}-  Fundo esquerdo}\\
\texfamily ~~~~~~~~~~~~~~~~((fromIntegral~(-(fst~tamJanela)))~/~2)~~~\\
\texfamily ~~~~~~~~~~~~~~~~{\rmfamily-{}-  Superior e ponto na esquerda}\\
\texfamily ~~~~~~~~~~~~~~~~((fromIntegral~~~(snd~tamJanela)~)~/~2)~~~\\
\texfamily ~~~~~~~~~~~~~~~~{\rmfamily-{}-  Inferior e ponto na direita}\\
\texfamily ~~~~~~~~~~~~~~~~((fromIntegral~(-(snd~tamJanela)))~/~2)~
\end{tabbing}
\end{enumerate}

%---------------------------------------------------------------
%---------------------------------------------------------------

\section{Estado inicial e fun\c c\~oes principais}

J\'a tendo os tipos e constantes definidas, \'e poss\'ivel definir o estado incial do jogo: a bola, os jogadores e o universo por completo.

\begin{tabbing}\texfamily
jogador0~=~{\itshape Jogador}~\char123 ~\char95 posY~~~=~0\\
\texfamily ~~~~~~~~~~~~~~~~~~~,~\char95 dirMov~=~{\itshape Parado}\\
\texfamily ~~~~~~~~~~~~~~~~~~~,~\char95 pts~~~~=~0~\char125 \\
\texfamily ~~~~~~~~~~~~~~~~~~~\\
\texfamily bola0~~~~=~{\itshape Bola}~~~~\char123 ~\char95 angulo~=~45\\
\texfamily ~~~~~~~~~~~~~~~~~~~,~\char95 posXY~~=~(0,0)\\
\texfamily ~~~~~~~~~~~~~~~~~~~,~\char95 veloc~~=~7~\char125 \\
\texfamily ~~~~~~~~~~~~~~~~~~~\\
\texfamily jogo0~~~~=~{\itshape Jogo}~~~~\char123 ~\char95 player1~~~~~=~jogador0\\
\texfamily ~~~~~~~~~~~~~~~~~~~,~\char95 player2~~~~~=~jogador0\\
\texfamily ~~~~~~~~~~~~~~~~~~~,~\char95 pong~~~~~~~~=~bola0\\
\texfamily ~~~~~~~~~~~~~~~~~~~,~\char95 ultimoToque~=~{\itshape Topo}\\
\texfamily ~~~~~~~~~~~~~~~~~~~,~\char95 ultimoPonto~=~{\itshape Esq}\\
\texfamily ~~~~~~~~~~~~~~~~~~~,~\char95 atrasoPonto~=~delayInit~\char125 
\end{tabbing}

O jogo \'e baseado na fun\c c\~ao \text{\ttfamily playIO} do \text{\ttfamily gloss}. Ela exige a descri\c c\~ao da janela,
cor de fundo,
taxa atualiza\c c\~ao da tela,
uma \'unica constante representando o universo do jogo,
uma fun\c c\~ao para renderizar o jogo,
outra para lidar com eventos do jogador,
e outra para adiatnar o estado do jogo segundo a passagem do tempo.

\begin{tabbing}\texfamily
jogarIO~j~=~playIO~\\
\texfamily ~~~~({\itshape InWindow}~\char34 Pong\char34 ~tamJanela~(40,40))~~{\rmfamily-{}-  Janela do jogo}\\
\texfamily ~~~~black~~~~~~~~~~~{\rmfamily-{}-  Cor de fundo                      }\\
\texfamily ~~~~fps~~~~~~~~~~~~~{\rmfamily-{}-  Taxa FPS}\\
\texfamily ~~~~j~~~~~~~~~~~~~~~{\rmfamily-{}-  Entrada (tipo Jogo)}\\
\texfamily ~~~~renderizar~~~~~~{\rmfamily-{}-  Converto o mundo para Picture}\\
\texfamily ~~~~eventoTecla~~~~~{\rmfamily-{}-  Lidar com eventos IO}\\
\texfamily ~~~~passoGeral~~~~~~{\rmfamily-{}-  Lida com a passagem do tempo}
\end{tabbing}

Na fun\c c\~ao principal \text{\ttfamily main}, a inicializa\c c\~ao do jogo come\c ca por definir um \^angulo aleat\'orio para o movimento da bola.
Percebe-se que em \text{\ttfamily bola0}, a posi\c c\~ao inicial \'e $(0,0)$,
que corresponde ao centro da tela.
Diferente do \text{\ttfamily Pong} original, ou at\'e mesmo do \text{\ttfamily Ping~Pong} anterior a ele,
nesta implementa\c c\~ao, a bola sempre partir\'a do centro da tela,
num \^angulo aleat\'orio, come\c cando pela direita.

\begin{tabbing}\texfamily
main~::~{\itshape IO}~()\\
\texfamily main~=~{\bfseries let}~f~x~=~{\bfseries if}~odd~x~{\bfseries then}~x~{\bfseries else}~(-x)\\
\texfamily ~~~~~~~{\bfseries in}~{\bfseries do}~a~\char'06~randomRIO~(5,~45)~::~{\itshape IO}~{\itshape Int}\\
\texfamily ~~~~~~~~~~~~~s~\char'06~newStdGen\\
\texfamily ~~~~~~~~~~~~~jogarIO~\$~set~(pong~\char'00~angulo)~(fromIntegral~\char'00~f~\$~a)~\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~\$~jogo0
\end{tabbing}

\subsection{Fun\c c\~oes principais}

Por exig\^encia de \text{\ttfamily playIO}, \text{\ttfamily renderizar}, \text{\ttfamily eventoTecla} e \text{\ttfamily passoGeral} devem ser tais que:

\begin{tabbing}\texfamily
j~~~~~~~~~~~~::~a\\
\texfamily renderizar~~~::~a~\char'31~{\itshape IO}~{\itshape Picture}\\
\texfamily eventoTecla~~::~{\itshape Event}~\char'31~a~\char'31~{\itshape IO}~a\\
\texfamily passoGeral~~~::~{\itshape Float}~\char'31~a~\char'31~{\itshape IO}~a
\end{tabbing}
E j\'a defin\'i-las ajuda no processo de desenvolvimento do programa:
come\c cando pelas fun\c c\~oes de mais alta ordem e partindo para a elementares,
na medida do necess\'ario.

\subsubsection{Desenhar na tela}

A fun\c c\~ao \text{\ttfamily renderizar} usa \text{\ttfamily \char95{}player1} e \text{\ttfamily \char95{}player2} de \text{\ttfamily Jogo} para desenh\'a-los na tela, mais \text{\ttfamily \char95{}pong} para desenhar a bola.

\begin{tabbing}\texfamily
renderizar~::~{\itshape Jogo}~\char'31~{\itshape IO}~{\itshape Picture}\\
\texfamily renderizar~jogo~=\\
\texfamily ~~{\bfseries let}~js~~=~zip~~~[{\itshape Esq},{\itshape Dir}]~[\char95 player1~jogo,~\char95 player2~jogo]\\
\texfamily ~~~~~~b~~~=~\char95 pong~jogo\\
\texfamily ~~{\bfseries in}~~return~\char'00~pictures~\$~(renderBola~b)~:~(map~renderJogador~js)
\end{tabbing}
Acabamos de definir, portanto, que \text{\ttfamily \char95{}player1} fica do lado esquerdo da tela,
e \text{\ttfamily \char95{}player2} fica do lado direto.

\subsubsection{Entrada humana}\label{sec:entrada}

\text{\ttfamily gloss} define o tipo \text{\ttfamily Event} para encapsular todas as poss\'iveis a\c c\~oes do usu\'ario.
No caso deste jogo, fica definido que:
\begin{enumerate}
    \item As teclas \text{\ttfamily W} e \text{\ttfamily S} movimentam o jogador \`a esquerda da tela (\text{\ttfamily \char95{}player1}).
    \item As teclas $\uparrow$ e $\downarrow$ movimentam o jogador \`a direita da tela (\text{\ttfamily \char95{}player2}).
    \item Qualquer outra entrada (telca, cliques, movimento do mouse) n\~ao realizam nenhuma a\c c\~ao.
\end{enumerate}
Nesse sentido, fica clara a conveni\^encia de se usar \text{\ttfamily Maybe} para tratar os eventos de tecla.
Como definimos que \text{\ttfamily Jogador} carrega sua dire\c c\~ao do movimento, \text{\ttfamily \char95{}dirMov},
basta que este valor seja alterado segundo a entrada do jogador.

\begin{tabbing}\texfamily
eventoTecla~::~{\itshape Event}~\char'31~{\itshape Jogo}~\char'31~{\itshape IO}~{\itshape Jogo}\\
\texfamily eventoTecla~evento~jogo~=~\\
\texfamily ~~{\bfseries let}~tecla~=~lerTecla~evento~\\
\texfamily ~~{\bfseries in}~{\bfseries if}~isNothing~tecla~\\
\texfamily ~~~~~{\bfseries then}~return~jogo\\
\texfamily ~~~~~{\bfseries else}~{\bfseries let}~(p,d)~=~fromJust~tecla\\
\texfamily ~~~~~~~~~~{\bfseries in}~{\bfseries do}~return~\$~set~(p~\char'00~dirMov)~d~jogo
\end{tabbing}

Daqui tamb\'em j\'a fica claro que a fun\c c\~ao elementar \text{\ttfamily lerTecla} dever\'a ter como sa\'ida uma dupla contendo a lente do jogador (\text{\ttfamily player1} ou \text{\ttfamily player2}),
e a traduzir a tecla pressiona num valor do tipo \text{\ttfamily Direcao}.

\subsubsection{Itera\c c\~ao do universo}
A \'ultima fun\c c\~ao principal \'e respons\'avel por atualizar o jogo
na seguinte sequ\^encia:
\begin{enumerate}
    \item Conta o tempo de atraso de cada ponto at\'e zerar;
    \item Detecta e age se a bola est\'a em posi\c c\~ao de colis\~ao;
    \item Move os jogadores para cima ou para baixo;
    \item Move a bola;
    \item Detecta se h\'a ponto (bola fora).
\end{enumerate}

\begin{tabbing}\texfamily
passoGeral~::~{\itshape Float}~\char'31~{\itshape Jogo}~\char'31~{\itshape IO}~{\itshape Jogo}\\
\texfamily passoGeral~dt~jogo~=~{\bfseries if}~\char95 atrasoPonto~jogo~>~0\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~{\bfseries then}~return~\$~over~atrasoPonto~(+(-dt))~jogo\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~{\bfseries else}~(detectColisao~jogo)~\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~~~~~>>=~(moverJogadores~passoJogador)~\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~~~~~>>=~moverBola\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~~~~~>>=~bolaFora
\end{tabbing}

%---------------------------------------------------------------
%---------------------------------------------------------------

\section{Renderizando o jogo}

Para cada jogador, usa-se \text{\ttfamily renderJogador}, que admite o uma dupla contendo
um lado da tela e o pr\'oprio jogador,
o qual carrega consigo sua posi\c c\~ao vertcial.
O desenho \'e um ret\^angulo branco, cujo tamanho segue as constantes globais.
\begin{tabbing}\texfamily
renderJogador~::~({\itshape Lado},{\itshape Jogador})~\char'31~{\itshape Picture}\\
\texfamily renderJogador~(l,j)~=~\\
\texfamily ~~~~{\bfseries let}~~p~~=~\char95 posY~j\\
\texfamily ~~~~~~~~~b~~=~color~white~\$~rectangleSolid~ladoJogador~compJogador\\
\texfamily ~~~~~~~~~x~~=~(/2)~\char'00~fromIntegral~\$~snd~tamJanela\\
\texfamily ~~~~{\bfseries in}~{\bfseries case}~l~{\bfseries of}~~{\itshape Dir}~~\char'31~translate~(~x~-~(ladoJogador/2))~p~b\\
\texfamily ~~~~~~~~~~~~~~~~~~{\itshape Esq}~~\char'31~translate~(-x~+~(ladoJogador/2))~p~b
\end{tabbing}

Um c\'irculo branco representa a bola. \text{\ttfamily renderBola} admite apenas \text{\ttfamily Bola}, que j\'a carrega em si mesma sua posi\c c\~ao $(x,y)$ na tela.

\begin{tabbing}\texfamily
renderBola~::~{\itshape Bola}~\char'31~{\itshape Picture}\\
\texfamily renderBola~b~=\\
\texfamily ~~~~{\bfseries let}~(x,y)~=~\char95 posXY~b~\\
\texfamily ~~~~{\bfseries in}~color~white~~\$~translate~x~y~\\
\texfamily ~~~~~~~~~~~~~~~~~~~~\$~circleSolid~raioBola
\end{tabbing}

%---------------------------------------------------------------
%---------------------------------------------------------------

\section{Entrada das teclas e movimento}

Seguindo a documenta\c c\~ao de \text{\ttfamily gloss},
e de acordo com o que definimos na Se\c{c}\~{a}o~\ref{sec:entrada}
pode-se escrever a fun\c c\~ao que ir\'a receber os eventos enviados \`a \text{\ttfamily eventoTecla},
que v\^em das fun\c c\~oes internas de \text{\ttfamily playIO}.

\begin{tabbing}\texfamily
lerTecla~({\itshape EventKey}~({\itshape Char}~c)~e~\char95 ~\char95 )\\
\texfamily ~~~~|~c~\char'36~'w'~\char'04~e~\char'36~{\itshape Down}~=~{\itshape Just}~(player1,~{\itshape Cima})\\
\texfamily ~~~~|~c~\char'36~'w'~\char'04~e~\char'36~{\itshape Up}~~~=~{\itshape Just}~(player1,~{\itshape Parado})\\
\texfamily ~~~~|~c~\char'36~'s'~\char'04~e~\char'36~{\itshape Down}~=~{\itshape Just}~(player1,~{\itshape Baixo})\\
\texfamily ~~~~|~c~\char'36~'s'~\char'04~e~\char'36~{\itshape Up}~~~=~{\itshape Just}~(player1,~{\itshape Parado})\\
\texfamily lerTecla~({\itshape EventKey}~({\itshape SpecialKey}~s)~e~\char95 ~\char95 )\\
\texfamily ~~~~|~s~\char'36~{\itshape KeyUp}~~~\char'04~e~\char'36~{\itshape Down}~=~{\itshape Just}~(player2,~{\itshape Cima})\\
\texfamily ~~~~|~s~\char'36~{\itshape KeyUp}~~~\char'04~e~\char'36~{\itshape Up}~~~=~{\itshape Just}~(player2,~{\itshape Parado})\\
\texfamily ~~~~|~s~\char'36~{\itshape KeyDown}~\char'04~e~\char'36~{\itshape Down}~=~{\itshape Just}~(player2,~{\itshape Baixo})\\
\texfamily ~~~~|~s~\char'36~{\itshape KeyDown}~\char'04~e~\char'36~{\itshape Up}~~~=~{\itshape Just}~(player2,~{\itshape Parado})\\
\texfamily lerTecla~\char95 ~=~{\itshape Nothing}
\end{tabbing}

Nota-se que n\~ao h\'a anota\c c\~ao de tipo para \text{\ttfamily lerTecla}.
Isso acontece porque ela retorna \text{\ttfamily player1} e \text{\ttfamily player2} e, sendo assim, 
seu tipo deveria ser
\begin{tabbing}\texfamily
lerTecla~::~{\itshape Event}~\char'31~{\itshape Maybe}~({\itshape Lens'}~{\itshape Jogo}~{\itshape Jogador},{\itshape Direcao})
\end{tabbing}
Por\'em, \text{\ttfamily Lens\char39{}} dentro de \text{\ttfamily Maybe} exige polimorfismo impredicativo,
o que ainda n\~ao \'e suportado pelo GHC,
mesmo se us\'assemos a extens\~ao \text{\ttfamily RankedNTypes}.
Portanto, conv\'em deixar que o tipo seja automaticamente inferido pelo compilador.
Isso resulta em:

\begin{tabbing}\texfamily
lerTecla~::~\char'24~\char123 f~::~*~\char'31~*~\char125 \\
\texfamily ~~~~~~~~~~\char'00~{\itshape Functor}~f\\
\texfamily ~~~~~~~~~=>~{\itshape Event}~\\
\texfamily ~~~~~~~~~~\char'31~{\itshape Maybe}~(({\itshape Jogador}~\char'31~f~{\itshape Jogador})~\char'31~{\itshape Jogo}~\char'31~f~{\itshape Jogo},~{\itshape Direcao}~)
\end{tabbing}
Por este tipo n\~ao ser muito ``leg\'ivel'', conv\'em n\~ao ser anotado.


\subsection{Movimenta\c c\~ao}

O movimento dos desenhos dos jogadores na tela
\'e realizado usando-se o valor \text{\ttfamily \char95{}dirMov} presente no registro do \text{\ttfamily Jogador},
dentro de \text{\ttfamily \char95{}palyer1} e \text{\ttfamily \char95{}player2} do registro \text{\ttfamily Jogo}.
Ele \'e restringido por \text{\ttfamily limJanela} e por \text{\ttfamily compJogador}.
Apesar de o passo do movimento ser tamb\'em uma constante global,
ele \'e passado para a fun\c c\~ao como um argumento para facilitar \emph{debugging}.

\begin{tabbing}\texfamily
moverJogadores~::~{\itshape Float}~\char'31~{\itshape Jogo}~\char'31~{\itshape IO}~{\itshape Jogo}\\
\texfamily moverJogadores~h~jogo~=~return~\$~over~player1~(moverJ~h)~\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\$~over~player2~(moverJ~h)~jogo\\
\texfamily ~~{\bfseries where}~moverJ~h~j~=~{\bfseries case}~(\char95 dirMov~j)~{\bfseries of}\\
\texfamily ~~~~~~~~~~{\itshape Cima}~~\char'31~{\bfseries if}~(\char95 posY~j)~+~compJogador~/~2~\char'35~view~\char95 3~limJanela\\
\texfamily ~~~~~~~~~~~~~~~~~~~{\bfseries then}~set~posY~\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~~~~~~~((view~\char95 3~limJanela)~-~compJogador/2)~j\\
\texfamily ~~~~~~~~~~~~~~~~~~~{\bfseries else}~over~posY~(+h)~j\\
\texfamily ~~~~~~~~~~{\itshape Baixo}~\char'31~{\bfseries if}~(\char95 posY~j)~-~compJogador~/~2~\char'34~view~\char95 4~limJanela\\
\texfamily ~~~~~~~~~~~~~~~~~~~{\bfseries then}~set~posY~\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~~~~~~~((view~\char95 4~limJanela)~+~compJogador/2)~j\\
\texfamily ~~~~~~~~~~~~~~~~~~~{\bfseries else}~over~posY~(+(-h))~j\\
\texfamily ~~~~~~~~~~\char95 ~~~~~\char'31~j
\end{tabbing}

Quanto \`a bola, os dados necess\'arios para sua movimenta\c c\~ao tamb\'em est\~ao contidos nela mesma.
N\~ao h\'a a\c c\~ao alguma dos jogadores que a fa\c a mudar de dire\c c\~ao ou sentido:
isto deve acontecer apenas em caso de colis\~ao.
Portanto, basta multiplicar \text{\ttfamily \char95{}veloc} pela varia\c c\~ao do tempo, que vem de \text{\ttfamily gloss} e considerar o \^angulo do movimento contido em \text{\ttfamily \char95{}angulo}.

\begin{tabbing}\texfamily
moverBola~::~{\itshape Jogo}~\char'31~{\itshape IO}~{\itshape Jogo}\\
\texfamily moverBola~jogo~=~return~\$~over~(pong~\char'00~posXY)~f~jogo\\
\texfamily ~~{\bfseries where}~v~=~view~(pong~\char'00~veloc)~jogo\\
\texfamily ~~~~~~~~a~=~view~(pong~\char'00~angulo)~jogo\\
\texfamily ~~~~~~~~f~(x,y)~=~(~x~+~v~*~(cos~(a~*~\char'07~/~180)~)\\
\texfamily ~~~~~~~~~~~~~~~~~~,~y~+~v~*~(sin~(a~*~\char'07~/~180)~)~)
\end{tabbing}

\section{Pontua\c c\~ao}

A condi\c c\~ao para que haja ponto \'e que a bola toque o limite de ponto
definido nas constantes globais, na esquerda ou na direita.
Se a bola sair pelo lado $l$, o procedimento seguido \'e o seguinte:
\begin{enumerate}
    \item Definir que ultimo ponto foi no lado $l$;
    
    \item Definir um \^angulo alet'\'orio para lan\c camento da bola:
    \begin{enumerate}
        \item Se \text{\ttfamily l~\char61{}\char61{}~Esq}, entre $-45^\circ{}$ e $+45^\circ{}$;
        \item Se \text{\ttfamily l~\char61{}\char61{}~Dir}, entre $135^\circ{}$ e $225^\circ{}$.
    \end{enumerate}

    \item Definir que o \'ultimo toque foi numa posi\c c\~ao ``nula'' (\text{\ttfamily Topo});
    \item Posicionar ambos os jogadores na posi\c c\~ao central;
    
    \item Incrementar a pontua\c c\~ao do jogador do lado oposto:
    \begin{enumerate}
        \item Se \text{\ttfamily l~\char61{}\char61{}~Esq}, incrimenta em \text{\ttfamily \char95{}player2};
        \item Se \text{\ttfamily l~\char61{}\char61{}~Dir}, incrementa em \text{\ttfamily \char95{}player1}.
    \end{enumerate}

    \item Resetar o contador de atraso para \text{\ttfamily delayInit};
    \item Posicionar a bola na origem da tela, $(0,0)$.
\end{enumerate}

\begin{tabbing}\texfamily
bolaFora~::~{\itshape Jogo}~\char'31~{\itshape IO}~{\itshape Jogo}\\
\texfamily bolaFora~jogo~=\\
\texfamily ~~{\bfseries let}~(x,y)~=~view~(pong~\char'00~posXY)~jogo\\
\texfamily ~~~~~~f~d~x~=~{\bfseries if}~d~\char'36~{\itshape Dir}\\
\texfamily ~~~~~~~~~~~~~~{\bfseries then}~{\bfseries if}~odd~x~{\bfseries then}~x~~~~~~~~~~{\bfseries else}~(-x)\\
\texfamily ~~~~~~~~~~~~~~{\bfseries else}~{\bfseries if}~odd~x~{\bfseries then}~(180~-~x)~~{\bfseries else}~(180~+~x)\\
\texfamily ~~~~~~pontoReset~l~a~j~=~set~(pong~\char'00~posXY)~(0,0)\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~~\$~set~atrasoPonto~delayInit\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~~\$~over~(l~\char'00~pts)~(+1)\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~~\$~set~(player1~\char'00~posY)~0\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~~\$~set~(player2~\char'00~posY)~0\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~~\$~set~ultimoToque~{\itshape Topo}\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~~\$~(\char'10j'~\char'31~{\bfseries if}~\char95 ultimoPonto~j'~\char'36~{\itshape Dir}~\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{\bfseries then}~set~(pong~\char'00~angulo)\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(fromIntegral~\char'00~(f~{\itshape Dir})~\$~a)~\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~j'\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{\bfseries else}~set~(pong~\char'00~angulo)~\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(fromIntegral~\char'00~(f~{\itshape Esq})~\$~a)~\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~j'~)\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~~\$~(\char'10j'~\char'31~{\bfseries if}~x~>~0~\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{\bfseries then}~set~ultimoPonto~{\itshape Dir}~j'\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{\bfseries else}~set~ultimoPonto~{\itshape Esq}~j'~)~j\\
\texfamily ~~{\bfseries in}~{\bfseries do}~s~\char'06~randomRIO~(5,~45)~::~{\itshape IO}~{\itshape Int}\\
\texfamily ~~~~~~~~{\bfseries if}~x~>~view~\char95 3~limJanela~\\
\texfamily ~~~~~~~~{\bfseries then}~return~\$~pontoReset~player1~s~jogo~\\
\texfamily ~~~~~~~~{\bfseries else}~{\bfseries if}~x~<~view~\char95 4~limJanela~\\
\texfamily ~~~~~~~~~~~~~{\bfseries then}~return~\$~pontoReset~player2~s~jogo\\
\texfamily ~~~~~~~~~~~~~{\bfseries else}~return~\$~jogo
\end{tabbing}

\begin{tabbing}\texfamily
detectColisao~::~{\itshape Jogo}~\char'31~{\itshape IO}~{\itshape Jogo}\\
\texfamily detectColisao~jogo\\
\texfamily ~~~~|~(y~-~raioBola)~~~~~~~~~~~~~~~<~view~(\char95 4)~limJanela~~~~~~\\
\texfamily ~~~~=~atualiza~{\itshape Base}~jogo\\
\texfamily ~~~~|~(y~+~raioBola)~~~~~~~~~~~~~~~>~view~(\char95 3)~limJanela~~~~~~\\
\texfamily ~~~~=~atualiza~{\itshape Topo}~jogo\\
\texfamily ~~~~|~(x~+~raioBola~+~ladoJogador)~>~view~(\char95 3)~limJanela~\char'04~c~\\
\texfamily ~~~~=~atualiza~{\itshape Dir}~~jogo\\
\texfamily ~~~~|~(x~-~raioBola~-~ladoJogador)~<~view~(\char95 4)~limJanela~\char'04~c~\\
\texfamily ~~~~=~atualiza~{\itshape Esq}~~jogo\\
\texfamily ~~~~|~otherwise~=~return~\$~jogo\\
\texfamily ~~~~~~{\bfseries where}~c~~~~~=~contatoJB~jogo\\
\texfamily ~~~~~~~~~~~~(x,y)~=~view~(pong~\char'00~posXY)~jogo\\
\texfamily ~~~~~~~~~~~~atualiza~d~j~=~{\bfseries if}~d~\char'36~\char95 ultimoToque~j~{\bfseries then}~return~j\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~~~~~~{\bfseries else}~return\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\$~set~ultimoToque~d\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\$~over~(pong~\char'00~angulo)~(refletir~d)~j\\
\texfamily \\
\texfamily {\rmfamily-{}-  Contato entre jogador e bola}\\
\texfamily contatoJB~::~{\itshape Jogo}~\char'31~~{\itshape Bool}\\
\texfamily contatoJB~jogo~=~\\
\texfamily ~~{\bfseries if}~((xB~<~0)~\char'04~(abs~(yB~-~yJ1))~<~(compJogador/2))~\char'37\\
\texfamily ~~~~~((xB~>~0)~\char'04~(abs~(yB~-~yJ2))~<~(compJogador/2))\\
\texfamily ~~{\bfseries then}~{\itshape True}~{\bfseries else}~{\itshape False}\\
\texfamily ~~~~{\bfseries where}~yJ1~~=~view~(player1~\char'00~posY)~jogo\\
\texfamily ~~~~~~~~~~yJ2~~=~view~(player2~\char'00~posY)~jogo\\
\texfamily ~~~~~~~~~~lEsq~=~view~\char95 4~limJanela\\
\texfamily ~~~~~~~~~~lDir~=~view~\char95 3~limJanela\\
\texfamily ~~~~~~~~~~(xB,yB)~~=~view~(pong~\char'00~posXY)~jogo\\
\texfamily \\
\texfamily {\rmfamily-{}-  Mudança de ângulo de uma bola devido a colisão}\\
\texfamily refletir~::~{\itshape Lado}~\char'31~{\itshape Float}~\char'31~{\itshape Float}\\
\texfamily refletir~l~a\\
\texfamily ~~~~|~l~\char'36~{\itshape Topo}~=~worker~a~270\\
\texfamily ~~~~|~l~\char'36~{\itshape Base}~=~worker~a~90\\
\texfamily ~~~~|~l~\char'36~{\itshape Esq}~~=~worker~a~0\\
\texfamily ~~~~|~l~\char'36~{\itshape Dir}~~=~worker~a~180\\
\texfamily ~~~~~~{\bfseries where}~worker~t~n~=~(n~+~90)~-~(t~-~(n~+~90))
\end{tabbing}

\end{document}
